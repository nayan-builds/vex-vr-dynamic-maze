{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode VR Python Project\n# \n# ------------------------------------------\n\nfrom collections import deque\n\n# Add project code in \"main\"\ndef main():\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    pen.set_pen_color(GREEN)\n    pen.move(DOWN)\n    solve_maze()\n\ndef solve_maze():\n    # graph stores the mapped maze as an undirected, unweighted graph data structure\n    # The graph data structure is a dictionary\n    # Keys are nodes as strings in format \"(x,y)\"\n    # Values are a list of connected nodes\n    graph = Graph()\n    robot = Robot()\n\n    paths_from_start = 0\n    start_visited = 0\n\n    # Calculate number of routes from start, when this equals \n    # the number of times the start has been visited, then the mapping is complete\n    # and the start has been returned to\n    for i in range(0, 3):\n        if not robot.wall_or_exit():\n            paths_from_start += 1\n        robot.turn_right()\n    if not robot.wall_or_exit():\n        paths_from_start += 1\n\n    graph.add_node(robot.position.to_string())\n    end_node = None\n\n    # Map the maze by hugging left wall\n    while paths_from_start > start_visited:\n        if robot.wall_or_exit():\n            robot.turn_right()\n        else:\n            robot.drive_forward()\n            if down_eye.detect(RED): # Set end_node when the red square has been reached\n                end_node = robot.position.to_string()\n                brain.print(\"End node found at: \" + robot.position.to_string())\n                brain.new_line()\n            \n            # Add node and connection to previous node after moving\n            # (won't be added if the node or connection already exists)\n            graph.add_node(robot.position.to_string())\n            graph.add_connection(robot.position.to_string(), robot.previous_position.to_string())\n            if robot.position.to_string() == \"(0,0)\":\n                start_visited += 1\n            robot.turn_left()\n    \n    drivetrain.turn_to_heading(0, DEGREES)\n\n    brain.print(graph.graph)\n    brain.new_line()\n    graph.print_maze(\"(0,0)\", end_node)\n\n    # Calculate and travel shortest route from start to end\n    pen.set_pen_color(BLUE)\n    robot.travel_path(graph.shortest_path(\"(0,0)\", end_node))\n\n    wait(2, SECONDS)\n\n    # Calculate and travel shortest route from end to start\n    pen.set_pen_color(RED)\n    robot.travel_path(graph.shortest_path(end_node, \"(0,0)\"))\n\ndef extract_coordinates(point):\n    # Returns x, y integers as a tuple from a \"(x,y)\" string\n    point = point.strip(\"()\")\n    point_x_str, point_y_str = point.split(\",\")\n\n    point_x = int(point_x_str)\n    point_y = int(point_y_str)\n    return point_x, point_y\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def to_string(self):\n        return \"(\" + str(self.x) + \",\" + str(self.y) + \")\"\n\nclass Robot:\n    def __init__(self):\n\n        self.position = Point(0, 0)\n    \n    def drive_forward(self, units = 1):\n        drivetrain.drive_for(FORWARD, 250 * units, MM)\n        self.previous_position = self.position\n\n        if drivetrain.heading(DEGREES) == 0:\n            self.position = Point(self.position.x, self.position.y + units)\n        elif drivetrain.heading(DEGREES) == 90:\n            self.position = Point(self.position.x + units, self.position.y)\n        elif drivetrain.heading(DEGREES) == 180:\n            self.position = Point(self.position.x, self.position.y - units)\n        elif drivetrain.heading(DEGREES) == 270:\n            self.position = Point(self.position.x - units, self.position.y)\n    \n    def turn_right(self):\n        drivetrain.turn_for(RIGHT, 90, DEGREES)\n\n    def turn_left(self):\n        drivetrain.turn_for(LEFT, 90, DEGREES)\n    \n    def wall_or_exit(self):\n        wall = front_distance.get_distance(MM) < 70\n        at_start = self.position.to_string() == \"(0,0)\"\n        at_end = down_eye.detect(RED)\n        void = front_distance.get_distance(MM) > 2900\n\n\n        # Treat the entrance and exit holes in the walls (void) as walls\n\n        return wall or (void and (at_start or at_end))\n\n\n    def travel_path(self, path):\n        if path[0] != self.position.to_string():\n            brain.print(\"Not at start position\")\n            return\n        forward_moves = 1\n        prev_heading = -1\n        current_heading = 0\n\n        prev_pos_x = self.position.x\n        prev_pos_y = self.position.y\n        for i in range(1, len(path)):\n\n            # Extract x, y from node string\n            next_pos_x, next_pos_y = extract_coordinates(path[i])\n\n            if next_pos_x > prev_pos_x:\n                #right\n                current_heading = 90\n            elif next_pos_x < prev_pos_x:\n                #left\n                current_heading = 270\n            elif next_pos_y > prev_pos_y:\n                #up\n                current_heading = 0\n            elif next_pos_y < prev_pos_y:\n                #down\n                current_heading = 180\n\n\n            if current_heading == prev_heading:\n                # If the travel direction is same as previous,\n                # add 1 forward move\n                # (to be moved when this is no longer true)\n                # This is so it can move several units in one\n                # movement, rather than moving and stopping multiple\n                # times.\n                forward_moves += 1\n            elif i == 1:\n                # Doesn't move on first node as it needs to check\n                # if the next node is going in the same direction\n                prev_heading = current_heading\n                drivetrain.turn_to_heading(current_heading, DEGREES)\n            else:\n                # If the current node is going in a different direction\n                # to previous, drive to previous node\n                self.drive_forward(forward_moves)\n                drivetrain.turn_to_heading(current_heading, DEGREES)\n                forward_moves = 1\n                prev_heading = current_heading\n            if i == len(path) - 1:\n                # If it is last node, move to it\n                self.drive_forward(forward_moves)\n            prev_pos_x = next_pos_x\n            prev_pos_y = next_pos_y\n\nclass Graph:\n    def __init__(self):\n        self.graph = {}\n\n    def add_connection(self, node1, node2):\n        if node2 not in self.graph[node1]:\n            self.graph[node1].append(node2)\n        if node1 not in self.graph[node2]:\n            self.graph[node2].append(node1)\n\n    def add_node(self, node):\n        if node not in self.graph:\n            self.graph[node] = []\n\n    def print_maze(self, start, end):\n        # Convert all node strings \"(x,y)\" (keys) to (x, y) tuples for \n        positions = set()\n        for node in self.graph.keys():\n            x, y = extract_coordinates(node)\n            positions.add((x, y))\n\n\n        # Determine the bounds of the maze\n        min_x = min(x for x, y in positions)\n        max_x = max(x for x, y in positions)\n        min_y = min(y for x, y in positions)\n        max_y = max(y for x, y in positions)\n\n        # Calculate the maze dimensions with an exterior border\n        # For each node there is a wall or gap (max_x - min_x + 1) * 2\n        # +1 for the last node, since it will have another wall on the\n        # other side\n        width = (max_x - min_x + 1) * 2 + 1\n        height = (max_y - min_y + 1) * 2 + 1\n\n        # Initialize the maze with walls (including exterior walls)\n        maze = [[\"█\" for i in range(width)] for i in range(height)]\n\n        # Fill in walkable spaces and connections\n        for x, y in positions:\n            grid_x = (x - min_x) * 2 + 1  # Offset by 1 for exterior walls\n            grid_y = (y - min_y) * 2 + 1\n            maze[grid_y][grid_x] = \" \"  # Walkable tile\n\n            # Check for horizontal connection\n            if (x + 1, y) in positions and f\"({x+1},{y})\" in self.graph[f\"({x},{y})\"]:\n                maze[grid_y][grid_x + 1] = \" \"\n\n            # Check for vertical connection\n            if (x, y + 1) in positions and f\"({x},{y+1})\" in self.graph[f\"({x},{y})\"]:\n                maze[grid_y + 1][grid_x] = \" \"\n\n        # Place start and end markers\n        def parse_coordinates(node):\n            x, y = extract_coordinates(node)\n            return (x - min_x) * 2 + 1, (y - min_y) * 2 + 1  # Normalize, scale, and offset\n\n        start_x, start_y = parse_coordinates(start)\n        end_x, end_y = parse_coordinates(end)\n        maze[start_y][start_x] = \"O\"\n        maze[end_y][end_x] = \"X\"\n\n        # Print the final maze (flipping Y-axis by reversing rows)\n        for row in maze[::-1]:\n            brain.print(\"\".join(row))\n            brain.new_line()\n\n        \n    def shortest_path(self, start, end):\n        # Finds the shortest path via a breadth-first traversal from start to end\n        graph = self.graph\n\n        # Stores whether each node has been visited\n        visited = {node: False for node in graph}\n        visited[start] = True\n        \n        # Stores the previous node for each node\n        predecessors = {node: None for node in graph}\n\n        # Stores the furthest reached nodes\n        queue = deque([start])\n\n        while queue:\n            # Check the neighbours of the next furthest reached node\n            current = queue.popleft()\n            for neighbour in graph[current]:\n                if not visited[neighbour]: # Not yet visited\n                    visited[neighbour] = True\n                    predecessors[neighbour] = current\n\n                    # Add the neighbour node to the queue of furthest\n                    # reached nodes\n                    queue.append(neighbour)\n\n                    # Stop if end has been found\n                    if neighbour == end:\n                        break\n        \n        # Reconstruct the shortest path from predecessors backwards\n        path = []\n        at = end\n        while at is not None:\n            # Stops when the node has no predecessor (start)\n            path.append(at)\n            at = predecessors[at]\n\n        # Reverse path (for start to end)\n        path.reverse()\n\n        # Return empty list if no path found\n        return path if path[0] == start else []\n\n\n            \n\n            \n# VR threads — Do not delete\nvr_thread(main)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}